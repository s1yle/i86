; ==============================================
; bootsect.asm - 中文注释版
; 操作系统引导扇区代码详解
; 原文件：boot/bootsect.asm
; ==============================================

; 第13课的引导扇区，包含文件路径已更新
; 注释：汇编器指令，说明代码将被加载到内存地址0x7c00处
; BIOS会将引导扇区（512字节）加载到0x7c00，然后跳转到这里执行
[org 0x7c00]

; 定义常量：内核加载的偏移地址
; 内核将被加载到内存地址0x1000处（4KB位置）
KERNEL_OFFSET equ 0x1000 ; 与我们链接内核时使用的地址相同

; ==================== 主程序开始 ====================
start:
    ; 保存引导驱动器号
    ; BIOS在启动时将引导驱动器号放在dl寄存器中（0x00表示软盘，0x80表示硬盘）
    mov [BOOT_DRIVE], dl ; 记住：BIOS在启动时将引导驱动器设置在dl中

    ; 设置栈指针
    ; 在实模式下，栈从高地址向低地址生长
    ; 我们将栈顶设置在0x9000处（36KB位置）
    mov bp, 0x9000  ; 设置栈基址指针
    mov sp, bp      ; 设置栈指针，初始时栈为空，栈顶=栈底

    ; 打印实模式启动消息
    mov bx, MSG_REAL_MODE 
    call print      ; 调用打印函数，显示"Started in 16-bit Real Mode"
    call print_nl   ; 换行

    ; 加载内核到内存
    call load_kernel ; 从磁盘读取内核

    ; 切换到保护模式
    call switch_to_pm ; 禁用中断，加载GDT等，最后跳转到'BEGIN_PM'

    ; 无限循环（永远不应该执行到这里）
    jmp $ ; 如果切换保护模式失败，会停在这里

; ==================== 包含文件 ====================
; 这些是外部的汇编文件，提供了各种功能
%include "boot/print.asm"        ; 实模式打印函数
%include "boot/print_hex.asm"    ; 打印十六进制数函数
%include "boot/disk.asm"         ; 磁盘读取函数
%include "boot/gdt.asm"          ; 全局描述符表定义
%include "boot/32bit_print.asm"  ; 保护模式打印函数
%include "boot/switch_pm.asm"    ; 切换到保护模式的函数

; ==================== 加载内核函数 ====================
; 功能：从磁盘加载内核到内存地址KERNEL_OFFSET(0x1000)处
; 使用16位实模式指令
[bits 16]
load_kernel:
    ; 显示加载内核的消息
    mov bx, MSG_LOAD_KERNEL
    call print
    call print_nl

    ; 设置磁盘读取参数：
    ; bx - 目标缓冲区地址（内核将被加载到0x1000）
    mov bx, KERNEL_OFFSET ; 从磁盘读取并存储到0x1000
    
    ; dh - 要读取的扇区数（我们的内核将来会更大，所以设置大一些）
    mov dh, 16 ; 读取16个扇区（16×512=8KB）
    
    ; dl - 驱动器号（从之前保存的BOOT_DRIVE获取）
    mov dl, [BOOT_DRIVE]
    
    ; 调用磁盘加载函数
    call disk_load
    
    ret ; 返回主程序

; ==================== 保护模式入口点 ====================
; 功能：保护模式下的初始化代码
; 使用32位保护模式指令
[bits 32]
BEGIN_PM:
    ; 打印保护模式消息
    mov ebx, MSG_PROT_MODE
    call print_string_pm ; 调用保护模式下的打印函数
    
    ; 跳转到内核入口点，将控制权交给内核
    ; KERNEL_OFFSET是0x1000，内核代码应该从这里开始执行
    call KERNEL_OFFSET ; 将控制权交给内核
    
    ; 如果内核返回控制（通常不应该），则进入无限循环
    jmp $ ; 当内核将控制权返回给我们时（如果发生）停留在这里

; ==================== 数据区 ====================
; 变量和字符串定义

; 引导驱动器号存储变量
; 将dl存储在内存中是个好主意，因为'dl'可能会被覆盖
BOOT_DRIVE db 0

; 字符串消息定义
; db - 定义字节，0表示字符串结束（C风格字符串）
MSG_REAL_MODE db "Started in 16-bit Real Mode", 0
MSG_PROT_MODE db "Landed in 32-bit Protected Mode", 0
MSG_LOAD_KERNEL db "Loading kernel into memory", 0

; ==================== 引导扇区填充和魔数 ====================
; 引导扇区必须是512字节，最后两个字节必须是0x55 0xaa
; BIOS通过这个魔数识别引导扇区

; 填充到510字节
; times指令重复指定的次数
; 510 - ($-$$) 计算从开始到当前位置的字节数，然后计算需要填充的字节数
; $$ 表示段开始地址，$ 表示当前位置
times 510 - ($-$$) db 0

; 引导扇区魔数（小端序：0x55 0xaa）
dw 0xaa55

; ==================== 引导扇区大小说明 ====================
; 引导扇区总大小：512字节
; 结构：
;   1. 引导代码：约200-300字节
;   2. 数据（字符串、变量）：约50字节
;   3. 填充：剩余字节用0填充
;   4. 魔数：最后2字节为0x55 0xaa
; 
; 内存布局：
;   0x7c00 - 0x7dff: 引导扇区（512字节）
;   0x1000: 内核加载地址
;   0x9000: 实模式栈顶
;   0x90000: 保护模式栈顶

; ==================== 重要概念 ====================
; 1. 实模式（Real Mode）：
;    - 16位模式，1MB内存空间
;    - 使用段:偏移地址（段地址×16 + 偏移地址）
;    - 可以直接调用BIOS中断
;
; 2. 保护模式（Protected Mode）：
;    - 32位模式，支持4GB内存
;    - 使用全局描述符表（GDT）管理内存段
;    - 不能直接调用BIOS中断
;
; 3. 引导过程：
;    BIOS -> 引导扇区(0x7c00) -> 加载内核 -> 切换到保护模式 -> 跳转到内核
;
; 4. 磁盘读取：
;    使用BIOS中断0x13，功能号0x02
;    参数：驱动器号(dl)、扇区数(dh)、目标缓冲区(es:bx)
